<!DOCTYPE html>
<html lang="en" xmlns:p="http://www.w3.org/1999/html">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Alpenglow Plan &amp; Documentation</title>

  <link rel="shortcut icon" type="image/x-icon" href="../../scenery/assets/logo-v1.svg">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shThemeDefault.css">

  <script>
    window.phet = window.phet || {};

    window.pendingDiagrams = [];
    window.addDiagram = ( id, callback ) => {
      window.pendingDiagrams.push( { id: id, callback: callback } );
    };
  </script>

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../chipper/js/sim-tests/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <script src="../../assert/js/assert.js"></script>
  <script src="../../tandem/js/PhetioIDUtils.js"></script>
  <script src="../../sherpa/lib/linebreak-1.1.0.js"></script>
  <script src="../../sherpa/lib/flatqueue-1.2.1.js"></script>
  <script src="../../sherpa/lib/paper-js-0.12.17.js"></script>
  <script src="../../sherpa/lib/he-1.1.1.js"></script>
  <script src="../../sherpa/lib/TextEncoderLite-3c9f6f0.js"></script>
  <script src="../../sherpa/lib/base64-js-1.2.0.js"></script>

  <script type="text/javascript">
    // window.assertions.enableAssert();
    // window.assertions.enableAssertSlow();
  </script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <link rel="stylesheet" href="../../sherpa/lib/codemirror-5.52.2.min.css">
  <link rel="stylesheet" href="../../sherpa/lib/codemirror-5.52.2.monokai.min.css">

  <script src="../../sherpa/lib/codemirror-5.52.2.min.js"></script>
  <script src="../../sherpa/lib/codemirror-5.52.2.javascript.min.js"></script>

  <script src="../../scenery/doc/extractFunctionJS.js"></script>

  <script src="./teapotObj.js"></script>

  <style>
    .CodeMirror {
      height: auto;
      border-radius: 5px;
      margin-top: 10px;
      margin-bottom: 10px;
      text-align: left;
    }

    .errors {
      border: 1px solid red;
    }

    .TODO::before {
      content: "TODO: ";
      font-weight: bold;
    }

    .TODO {
      color: red;
    }

    .example {
      margin: 0 auto;
      text-align: center;
    }

    .nav-list {
      padding-left: 8px;
      padding-right: 0px;
    }

    .nav-list li {
      line-height: 10px;
      font-size: 90%;
    }
  </style>
</head>

<body>

<script type="module">
  import '../../chipper/dist/js/scenery/js/main.js';
  import '../../chipper/dist/js/alpenglow/js/main.js';
  import '../../chipper/dist/js/phet-core/js/main.js';
  import '../../chipper/dist/js/axon/js/main.js';
  import '../../chipper/dist/js/dot/js/main.js';
  import '../../chipper/dist/js/kite/js/main.js';
  import '../../chipper/dist/js/utterance-queue/js/main.js';

  phet.scenery.Utils.polyfillRequestAnimationFrame();
</script>

<script type="module">

  // TODO: move to a standalone JS file!

  import { Node, Display } from '../../chipper/dist/js/scenery/js/imports.js';
  import { CombinedRaster, Rasterize } from '../../chipper/dist/js/alpenglow/js/imports.js';
  import Bounds2 from '../../chipper/dist/js/dot/js/Bounds2.js';
  import Matrix3 from '../../chipper/dist/js/dot/js/Matrix3.js';
  // import dot from '../../chipper/dist/js/dot/js/dot.js';
  // const v2 = dot.v2;
  // const v3 = dot.v3;
  // const v4 = dot.v4;
  //
  // const colors = [
  //   new Color( 62, 171, 3 ),
  //   new Color( 23, 180, 77 ),
  //   new Color( 24, 183, 138 ),
  //   new Color( 23, 178, 194 ),
  //   new Color( 20, 163, 238 ),
  //   new Color( 71, 136, 255 ),
  //   new Color( 171, 101, 255 ),
  //   new Color( 228, 72, 235 ),
  //   new Color( 252, 66, 186 ),
  //   new Color( 252, 82, 127 )
  // ];

  window.piecewiseOptions = {
    minLevels: 1,
    maxLevels: 10,
    // distanceEpsilon: 0.02,
    distanceEpsilon: 0.0002,
    curveEpsilon: 0.2
  };
  window.shapeToPolygons = shape => shape.subpaths.map( subpath => {
    return subpath.toPiecewiseLinear( window.piecewiseOptions ).segments.map( line => {
      return line.start;
    } );
  } );

  window.diagramFont = new phet.scenery.Font( {
    size: 12,
    family: 'Arial, sans-serif'
  } );

  window.sizeCanvas = canvas => {
    canvas.style.width = `${canvas.width / window.devicePixelRatio}px`;
    canvas.style.height = `${canvas.height / window.devicePixelRatio}px`;
  };

  window.getSceneryElement = ( node, width, height, background, renderer ) => {
    const subdiv = document.createElement( 'div' );
    subdiv.style.margin = '0 auto';
    const scene = new Node( { renderer: renderer } );
    const display = new Display( scene, {
      width: width,
      height: height,
      accessibility: true,
      container: subdiv,
      allowCSSHacks: false
    } );

    display.width = width;
    display.height = height;
    scene.addChild( node );
    display.backgroundColor = background;
    display.updateDisplay();
    scene.removeChild( node );
    return subdiv;
  };

  // composite Rasterize/CombinedRaster options
  window.getRasterizedElement = ( renderProgram, width, height, options ) => {
    const program = renderProgram.transformed( Matrix3.scaling( window.devicePixelRatio ) );

    const outputWidth = width * window.devicePixelRatio;
    const outputHeight = height * window.devicePixelRatio;

    const raster = new CombinedRaster( outputWidth, outputHeight, options );
    Rasterize.rasterize( program, raster, new Bounds2( 0, 0, outputWidth, outputHeight ), options );
    const canvas = Rasterize.imageDataToCanvas( raster.toImageData() );
    window.sizeCanvas( canvas );
    canvas.style.display = 'block';
    canvas.style.position = 'relative';
    canvas.style.margin = '0 auto';
    canvas.style.left = '0';
    canvas.style.top = '0';
    return canvas;
  };

  window.createRenderProgramSandbox = ( id, func, width, height, providedOptions ) => {

    const { js, jsBefore, jsAfter } = window.extractFunctionJS( func );

    const options = phet.phetCore.merge( {
      jsBefore: jsBefore,
      jsAfter: jsAfter
    }, providedOptions );

    const parentElement = document.getElementById( id );

    const displayContainerElement = document.createElement( 'div' );
    parentElement.appendChild( displayContainerElement );

    const codeContainerElement = document.createElement( 'div' );
    parentElement.appendChild( codeContainerElement );

    const errorsContainerElement = document.createElement( 'div' );
    parentElement.appendChild( errorsContainerElement );
    errorsContainerElement.classList.add( 'errors' );

    const codeMirror = CodeMirror( codeContainerElement, { // eslint-disable-line no-undef
      lineNumbers: true,
      tabSize: 2,
      value: js,
      mode: 'javascript',
      theme: 'monokai',
      lineWrapping: true
    } );

    const isDescendant = function( parent, child ) {
      let node = child;
      while ( node ) {
        if ( node === parent ) {
          return true;
        }

        // Traverse up to the parent
        node = node.parentNode;
      }

      // Go up until the root but couldn't find the `parent`
      return false;
    };

    window.addEventListener( 'keydown', event => {
      // if shift-enter is pressed
      if ( event.keyCode === 13 && event.shiftKey && isDescendant( document.getElementById( 'code' ), document.activeElement ) ) {
        run();

        event.preventDefault();
      }
    } );

    const run = async () => {


      displayContainerElement.style.backgroundColor = 'transparent';
      errorsContainerElement.style.display = 'none';

      try {
        const code = `
        ${Math.random()};
        let value = (${options.jsBefore}
          const dot = phet.dot;
          const alpenglow = phet.alpenglow;
          const v2 = dot.v2;
          const v3 = dot.v3;
          const v4 = dot.v4;
          const Bounds2 = dot.Bounds2;
          const Matrix3 = dot.Matrix3;
          const Vector2 = dot.Vector2;
          const Vector3 = dot.Vector3;
          const Vector4 = dot.Vector4;
          const RenderBlendType = alpenglow.RenderBlendType;
          const RenderComposeType = alpenglow.RenderComposeType;
          const RenderExtend = alpenglow.RenderExtend;
          const RenderProgram = alpenglow.RenderProgram;
          const RenderPath = alpenglow.RenderPath;
          const RenderPathBoolean = alpenglow.RenderPathBoolean;
          const RenderColor = alpenglow.RenderColor;
          const RenderColorSpace = alpenglow.RenderColorSpace;
          const RenderColorSpaceConversion = alpenglow.RenderColorSpaceConversion;
          const RenderAlpha = alpenglow.RenderAlpha;
          const RenderNormalize = alpenglow.RenderNormalize;
          const RenderPremultiply = alpenglow.RenderPremultiply;
          const RenderUnpremultiply = alpenglow.RenderUnpremultiply;
          const RenderSRGBToLinearSRGB = alpenglow.RenderSRGBToLinearSRGB;
          const RenderLinearSRGBToSRGB = alpenglow.RenderLinearSRGBToSRGB;
          const RenderOklabToLinearSRGB = alpenglow.RenderOklabToLinearSRGB;
          const RenderLinearSRGBToOklab = alpenglow.RenderLinearSRGBToOklab;
          const RenderLinearDisplayP3ToLinearSRGB = alpenglow.RenderLinearDisplayP3ToLinearSRGB;
          const RenderLinearSRGBToLinearDisplayP3 = alpenglow.RenderLinearSRGBToLinearDisplayP3;
          const RenderBlendCompose = alpenglow.RenderBlendCompose;
          const RenderStack = alpenglow.RenderStack;
          const RenderPlanar = alpenglow.RenderPlanar;
          const RenderDepthSort = alpenglow.RenderDepthSort;
          const RenderLight = alpenglow.RenderLight;
          const RenderNormalDebug = alpenglow.RenderNormalDebug;
          const RenderPhong = alpenglow.RenderPhong;
          const RenderFilter = alpenglow.RenderFilter;
          const RenderGradientStop = alpenglow.RenderGradientStop;
          const RenderImage = alpenglow.RenderImage;
          const RenderLinearBlend = alpenglow.RenderLinearBlend;
          const RenderLinearBlendAccuracy = alpenglow.RenderLinearBlendAccuracy;
          const RenderBarycentricBlend = alpenglow.RenderBarycentricBlend;
          const RenderBarycentricBlendAccuracy = alpenglow.RenderBarycentricBlendAccuracy;
          const RenderBarycentricPerspectiveBlend = alpenglow.RenderBarycentricPerspectiveBlend;
          const RenderBarycentricPerspectiveBlendAccuracy = alpenglow.RenderBarycentricPerspectiveBlendAccuracy;
          const RenderLinearGradient = alpenglow.RenderLinearGradient;
          const RenderLinearGradientAccuracy = alpenglow.RenderLinearGradientAccuracy;
          const RenderRadialBlend = alpenglow.RenderRadialBlend;
          const RenderRadialBlendAccuracy = alpenglow.RenderRadialBlendAccuracy;
          const RenderRadialGradient = alpenglow.RenderRadialGradient;
          const RenderRadialGradientAccuracy = alpenglow.RenderRadialGradientAccuracy;
          const RenderResampleType = alpenglow.RenderResampleType;

          ${codeMirror.getValue()}
          ${options.jsAfter}
        )();
        export default value;`;

        // Assumes it's in a function, differently from the sandbox
        const dataURI = `data:text/javascript;base64,${btoa( code )}`;

        const program = ( await import( dataURI ) ).default;

        const element = window.getRasterizedElement( program, width, height, options );

        // Clear content
        while ( displayContainerElement.firstChild ) {
          displayContainerElement.removeChild( displayContainerElement.lastChild );
        }
        displayContainerElement.appendChild( element );
        displayContainerElement.style.opacity = '100%';
      }
      catch( e ) {
        console.error( e );
        displayContainerElement.style.backgroundColor = 'rgba(255,0,0,0.2)';
        errorsContainerElement.style.display = 'block';
        errorsContainerElement.innerHTML = `<pre>${e}</pre>`;
        displayContainerElement.style.opacity = '50%';
      }
    };

    codeMirror.on( 'change', editor => run && run() );

    run();
  };

  setTimeout( () => {
    const addDiagram = ( id, callback ) => {
      const container = document.getElementById( id );
      if ( container ) {
        const diagram = callback();
        container.appendChild( diagram );
      }
    };
    window.addDiagram = addDiagram;
    window.pendingDiagrams.forEach( diagram => setTimeout( () => addDiagram( diagram.id, diagram.callback ), 0 ) );
  }, 0 );

</script>

<!-- Our code, in either the concatenated 'with comments' version or the minified version -->
<!--<script src="../../phet-lib/dist/phet-lib.debug.js"></script>-->
<!--<script src="../../phet-lib/dist/phet-lib.min.js"></script>-->

<div class="row-fluid">
  <div class="span2"></div>
  <div class="span8">
    <div class="page-header" style="text-align: center;">
      <h1>Alpenglow Plan &amp; Documentation</h1>
    </div>
  </div>
  <div class="span2"></div>
</div>

<div class="row-fluid">
  <div class="span2 hidden-phone">
    <ul class="nav nav-list">
      <li><a href="#overview">Overview</a></li>
      <li>
        <a href="#concepts">Concepts</a>
        <ul class="nav nav-list">
          <li><a href="#polygonalFaces">Polygonal Faces</a></li>
          <li><a href="#clipping">Clipping</a></li>
          <li><a href="#antialiasing">Anti-Aliasing</a></li>
          <li>
            <a href="#renderProgram">RenderProgram</a>
            <ul class="nav nav-list">
              <li><a href="#RenderColor">RenderColor</a></li>
              <li><a href="#RenderPathBoolean">RenderPathBoolean</a></li>
              <li><a href="#RenderStack">RenderStack</a></li>
              <li><a href="#RenderLinearBlend">RenderLinearBlend</a></li>
              <li><a href="#RenderLinearGradient">RenderLinearGradient</a></li>
              <li><a href="#RenderRadialBlend">RenderRadialBlend</a></li>
              <li><a href="#RenderRadialGradient">RenderRadialGradient</a></li>
              <li><a href="#RenderBlendCompose">RenderBlendCompose</a></li>
              <li><a href="#renderProgram-simplification">Simplification</a></li>
              <li><a href="#renderProgram-execution">Execution</a></li>
            </ul>
          </li>
          <li>
            <a href="#WGSL">WGSL</a>
            <ul class="nav nav-list">
              <li><a href="#WGSL-snippets">Snippets</a></li>
              <li><a href="#WGSL-preprocessing">Preprocessing</a></li>
              <li><a href="#WGSL-minification">Minification</a></li>
              <li><a href="#WGSL-mangling">Mangling</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <a href="#stages">Stages</a>
        <ul class="nav nav-list">
          <li><a href="#stage-transforms">Transforms</a></li>
          <li><a href="#stage-subdivision">Subdivision</a></li>
          <li><a href="#stage-bounds">Bounds</a></li>
          <li><a href="#stage-tiling">Tiling</a></li>
          <li><a href="#stage-integerTransform">Integer Transform</a></li>
          <li><a href="#stage-hilbertSort">Hilbert Sort</a></li>
          <li><a href="#stage-intersection">Intersection</a></li>
          <li><a href="#stage-split">Split</a></li>
          <li><a href="#stage-edgeSort">Edge Sort</a></li>
          <li><a href="#stage-filterConnect">Filter &amp; Connect</a></li>
          <li><a href="#stage-boundaryTrace">Boundary Trace</a></li>
          <li><a href="#stage-faceHoles">Face Holes</a></li>
          <li><a href="#stage-windingMaps">Winding Maps</a></li>
          <li><a href="#stage-renderProgramSimplification">RenderProgram Simplification</a></li>
          <li><a href="#stage-renderableFaceCreation">RenderableFace Creation</a></li>
          <li><a href="#stage-splitPrograms">Split Programs</a></li>
          <li><a href="#stage-rasterize">Rasterize</a></li>
        </ul>
      </li>
    </ul>
  </div>
  <div class="span8">
    <h2 id="overview">Overview</h2>

    <p>
      Alpenglow is an experimental rasterizer. It is meant to take in a scene description and efficiently output the
      corresponding image.
    </p>

    <p>
      <strong>
        Please contact the author (Jonathan Olson, jonathan.olson@colorado.edu) for any questions or comments, no matter how small!
      </strong>
    </p>

    <p class="TODO">
      Create section on the polygonal filters
    </p>

    <p class="TODO">
      Include the integrals docs (need MathJax)
    </p>

    <p class="TODO">
      Include the flowchart docs (need Mermaid)
    </p>

    <p class="TODO">
      Add TODO levels here, so we can flag critical/important ones
    </p>

    <h3>Technology: Primarily WebGPU</h3>

    <p>
      The goal is to primarily use WebGPU for rendering, but to also support WebGL 2 as much as possible, with software
      fallback (and for testing/development). In addition to a normal software route, there is a async/await
      parallelized form that can execute with the same execution model that WebGPU would use (with workgroups, storage
      buffers, etc.), that is used for validation, testing, and debugging.
    </p>

    <p class="TODO">
      Document Parallel execution setup somewhere.
    </p>

    <p class="TODO">
      Measure workgroup execution order on GPUs to see if we can schedule asymmetric (large) load workgroups first somehow.
    </p>

    <h3>Methods: Solve the Occlusion Problem First</h3>

    <p>
      The goal is to solve the problem quickly and with high quality by using polygonal boolean-operation
      approaches where we can get a list of polygonal faces where each input path is either fully contained or fully
      excluded in each face. We can then use high-performance approaches to rasterize each face independently, then
      accumulate while avoiding multisampling and conflation artifacts. Often these faces will be of constant color,
      which can very efficiently be displayed (we skip the per-pixel blending with the completely-occluded background
      contents).
    </p>

    <div class="row-fluid">
      <div class="span4 example">
        <div id="conflation-canvas"></div>
        Conflation artifacts (Canvas)
      </div>
      <div class="span4 example">
        <div id="conflation-svg"></div>
        Conflation artifacts (SVG)
      </div>
      <div class="span4 example">
        <div id="conflation-default"></div>
        No artifacts (Alpenglow CPU)
      </div>
    </div>

    <script type="module">
      import { Color, Node, Path, Rectangle } from '../../chipper/dist/js/scenery/js/imports.js';
      import { RenderColor, RenderStack, RenderPathBoolean, RenderPath, RenderFromNode, RenderColorSpace } from '../../chipper/dist/js/alpenglow/js/imports.js';
      import { Shape } from '../../chipper/dist/js/kite/js/imports.js';
      import Vector2 from '../../chipper/dist/js/dot/js/Vector2.js';
      import dot from '../../chipper/dist/js/dot/js/dot.js';
      const v2 = dot.v2;
      const v4 = dot.v4;

      const getConflation = ( type, pointCount ) => {
        const width = 128;
        const height = 128;

        const center = v2( width / 2 + 0.15992094, height / 2 + 0.426296 );
        const radius = width * 0.45;

        const polygons = [];
        const colors = [];
        for ( let i = 0; i < pointCount; i++ ) {
          const polygon = [];
          const angle0 = i * 2 * Math.PI / pointCount;
          const angle1 = ( i + 1 ) * 2 * Math.PI / pointCount;

          const chroma = Vector2.createPolar( 0.1, angle0 );
          colors.push( RenderColor.gamutMapSRGB( RenderColor.convert( v4( 0.5, chroma.x, chroma.y, 1 ), RenderColorSpace.oklab, RenderColorSpace.sRGB ) ) );

          const p0 = v2( center.x + radius * Math.cos( angle0 ), center.y + radius * Math.sin( angle0 ) );
          const p1 = v2( center.x + radius * Math.cos( angle1 ), center.y + radius * Math.sin( angle1 ) );

          polygon.push( center );
          polygon.push( p0 );
          polygon.push( p1 );
          polygons.push( polygon );
        }

        if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
          return window.getSceneryElement(
            new Node( {
              children: [
                new Rectangle( 0, 64, 128, 64, { fill: 'black' } ),
                ...polygons.map( ( poly, i ) => {
                  return new Path( Shape.polygon( poly ), { fill: new Color( colors[ i ].x * 255, colors[ i ].y * 255, colors[ i ].z * 255, 1 ) } );
                } )
              ]
            } ),
            width, height, 'white', type
          );
        }
        else if ( type === 'default' ) {
          const program = new RenderStack(
            [
              new RenderPathBoolean(
                new RenderPath( 'nonzero', [ [
                  v2( 0, 64 ),
                  v2( 128, 64 ),
                  v2( 128, 128 ),
                  v2( 0, 128 )
                ] ] ),
                RenderFromNode.colorFrom( 'black' ),
                RenderFromNode.colorFrom( 'white' )
              ),
              ...polygons.map( ( polygon, i ) => new RenderPathBoolean(
                new RenderPath( 'nonzero', [ polygon ] ),
                new RenderColor( colors[ i ] ),
                RenderColor.TRANSPARENT
              ) )
            ]
          );

          return window.getRasterizedElement( program, width, height );
        }
        else {
          throw new Error( 'unknown type' );
        }
      };

      window.addDiagram( 'conflation-canvas', () => getConflation( 'canvas', 100 ) );
      window.addDiagram( 'conflation-svg', () => getConflation( 'svg', 100 ) );
      window.addDiagram( 'conflation-default', () => getConflation( 'default', 100 ) );
    </script>

    <h2 id="concepts">Concepts</h2>

    <h3 id="polygonalFaces">Polygonal Faces</h3>

    <p>
      Polygonal faces are used pervasively throughout Alpenglow. In general, our data structures are designed to support
      <a href="https://en.wikipedia.org/wiki/Polygon_with_holes">polygons with holes</a>, and more generally, the
      primitive is a "list of polygons". An example is the following diagram, which can be stored in different ways:
    </p>

    <div class="example">
      <div id="polygonal-face-example"></div>
    </div>

    <p>
      All of the storage representations below conform to the <code>ClippableFace</code> interface in the software
      implementation.
    </p>

    <h4>Polygonal Form</h4>

    <p>
      It can be represented in the polygonal form as three (directed) lists of vertices (with a <a href="https://en.wikipedia.org/wiki/Nonzero-rule">nonzero winding rule</a>):
    </p>

    <p>
      (0,&nbsp;0),
      (10,&nbsp;0),
      (10,&nbsp;2),
      (2,&nbsp;10),
      (0,&nbsp;10)
      <br>
      (2,&nbsp;2),
      (2,&nbsp;7),
      (7,&nbsp;2)
      <br>
      (9,&nbsp;9),
      (6,&nbsp;9),
      (9,&nbsp;6)
    </p>

    <p>
      where there is a line (edge) between each consecutive pair of vertices, and the last vertex is connected to the
      first vertex. This is compact, however the order is critical. This can cause certain operations (e.g. circular
      clipping, some tracing) to be slower than other methods. This is handled by <code>PolygonalFace</code> in the
      software implementation.
    </p>

    <h4>Edge Form</h4>

    <p>
      For much of Alpenglow's needs, things work better if we consider the list of edges itself (with start/end vertices):
    </p>

    <p>
      (0,&nbsp;0)&nbsp;=>&nbsp;(10,&nbsp;0),
      (10,&nbsp;0)&nbsp;=>&nbsp;(10,&nbsp;2),
      (10,&nbsp;2)&nbsp;=>&nbsp;(2,&nbsp;10),
      (2,&nbsp;10)&nbsp;=>&nbsp;(0,&nbsp;10),
      (0,&nbsp;10)&nbsp;=>&nbsp;(0,&nbsp;0)

      (2,&nbsp;2)&nbsp;=>&nbsp;(2,&nbsp;7),
      (2,&nbsp;7)&nbsp;=>&nbsp;(7,&nbsp;2),
      (7,&nbsp;2)&nbsp;=>&nbsp;(2,&nbsp;2)

      (9,&nbsp;9)&nbsp;=>&nbsp;(6,&nbsp;9),
      (6,&nbsp;9)&nbsp;=>&nbsp;(9,&nbsp;6),
      (9,&nbsp;6)&nbsp;=>&nbsp;(9,&nbsp;9)
    </p>

    <p>
      Now, for most critical operations, order doesn't matter, and each edge can be considered in isolation.
      We won't need to sort things during/after operations, but also certain operations might need to generate more
      edges that get canceled out (whereas with polygonal data, we could detect it and simplify in higher-performance
      ways). This form is handled by <code>EdgedFace</code> in the software implementation.
    </p>

    <h4>Degenerate Edges</h4>

    <p>
      Additionally, we can actually construct this with an equivalent single (degenerate) polygon. Since we only care
      about the filled area, it turns out that edges that "reverse" over each other won't contribute to the filled area,
      so we can double-back. Thus the following diagram:
    </p>

    <div class="example">
      <div id="polygonal-face-canceling"></div>
    </div>

    <p>
      can be constructed with an equivalent area with the following polygon:
    </p>

    <p>
      (0,&nbsp;0),
      (10,&nbsp;0),
      (10,&nbsp;2),
      (7,&nbsp;2),
      (2,&nbsp;2),
      (2,&nbsp;7),
      (6,&nbsp;9),
      (9,&nbsp;6),
      (9,&nbsp;9),
      (6,&nbsp;9),
      (2,&nbsp;7),
      (7,&nbsp;2),
      (10,&nbsp;2),
      (2,&nbsp;10),
      (0,&nbsp;10)
    </p>

    <h4>Edge-Clipped Form</h4>

    <p>
      It turns out, for computational complexity of future clipping operations (see below), it is very helpful to NOT
      directly store the edges that go along the full edge of the clipping rectangle (e.g. the 0,0 to 10,10 region in
      the diagram). Instead, those edges will be counted. Due to the property above of degenerate edges, these counts
      can be added together to add the contribution of these "clipped" edges.
    </p>

    <p>
      The diagram below shows the edge orientations that get positive (+1) counts. Reversed edges will get negative (-1)
      counts:
    </p>

    <div class="example">
      <div id="polygonal-face-edge-clips"></div>
    </div>

    <p>
      Thus the edge-clipped version (for the 0,0 to 10,10 bounds) will have the following edges and counts:
    </p>

    <div class="example">
      <div id="polygonal-face-edge-clipped"></div>
    </div>

    <p>
      (10,&nbsp;0)&nbsp;=>&nbsp;(10,&nbsp;2),
      (10,&nbsp;2)&nbsp;=>&nbsp;(2,&nbsp;10),
      (2,&nbsp;10)&nbsp;=>&nbsp;(0,&nbsp;10),

      (2,&nbsp;2)&nbsp;=>&nbsp;(2,&nbsp;7),
      (2,&nbsp;7)&nbsp;=>&nbsp;(7,&nbsp;2),
      (7,&nbsp;2)&nbsp;=>&nbsp;(2,&nbsp;2)

      (9,&nbsp;9)&nbsp;=>&nbsp;(6,&nbsp;9),
      (6,&nbsp;9)&nbsp;=>&nbsp;(9,&nbsp;6),
      (9,&nbsp;6)&nbsp;=>&nbsp;(9,&nbsp;9)
    </p>

    <p>
      This is handled by the <code>EdgedClippedFace</code> in the software implementation.
    </p>

    <script type="module">
      import ArrowNode from '../../chipper/dist/js/scenery-phet/js/ArrowNode.js';

      const outputSize = 256;
      const size = 10;
      const padding = 40;

      const matrix = phet.dot.Matrix3.translation( padding, padding ).timesMatrix( phet.dot.Matrix3.scaling( ( outputSize - 2 * padding ) / size ) );
      const bounds = new phet.dot.Bounds2( 0, 0, 10, 10 );

      const dottedRect = phet.scenery.Rectangle.bounds( bounds.transformed( matrix ), {
        stroke: 'black',
        lineWidth: 0.5,
        lineDash: [ 2, 2 ]
      } );

      const v2 = phet.dot.v2;
      const polygons = [
        [
          v2( 0, 0 ),
          v2( 10, 0 ),
          v2( 10, 2 ),
          v2( 2, 10 ),
          v2( 0, 10 )
        ],
        [
          v2( 2, 2 ),
          v2( 2, 7 ),
          v2( 7, 2 )
        ],
        [
          v2( 9, 9 ),
          v2( 6, 9 ),
          v2( 9, 6 )
        ]
      ];

      const shape = phet.alpenglow.LinearEdge.polygonsToShape( polygons ).transformed( matrix );
      const edges = phet.alpenglow.LinearEdge.fromPolygons( polygons );

      const filledPath = new phet.scenery.Path( shape, {
        fill: 'rgba(255,0,0,0.7)'
      } );

      const arrowOptions = {
        headHeight: 6,
        headWidth: 4,
        tailWidth: 0.2
      };

      const arrowsNode = new phet.scenery.Node( {
        children: edges.map( edge => {
          const start = matrix.timesVector2( edge.startPoint );
          const end = matrix.timesVector2( edge.endPoint );
          return new ArrowNode( start.x, start.y, end.x, end.y, arrowOptions );
        } )
      } );

      const edgeClippedArrowsNode = new phet.scenery.Node( {
        children: edges.map( edge => {
          if ( ( edge.startPoint.x === 0 && edge.startPoint.y === 0 ) || ( edge.endPoint.x === 0 && edge.endPoint.y === 0 ) ) {
            return null;
          }
          const start = matrix.timesVector2( edge.startPoint );
          const end = matrix.timesVector2( edge.endPoint );
          return new ArrowNode( start.x, start.y, end.x, end.y, arrowOptions );
        } ).filter( _.identity )
      } );

      const toArray = v => [ v.x, v.y ];
      const extraArrowsNode = new phet.scenery.Node( {
        children: [
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 10, 1.93 ) ) ),
            ...toArray( matrix.timesVector2( v2( 7, 1.93 ) ) ),
            arrowOptions
          ),
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 7, 2.07 ) ) ),
            ...toArray( matrix.timesVector2( v2( 10, 2.07 ) ) ),
            arrowOptions
          ),
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 2, 7.08 ) ) ),
            ...toArray( matrix.timesVector2( v2( 6, 9.08 ) ) ),
            arrowOptions
          ),
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 6, 8.92 ) ) ),
            ...toArray( matrix.timesVector2( v2( 2, 6.92 ) ) ),
            arrowOptions
          )
        ]
      } );

      const edgeClipArrowsNode = new phet.scenery.Node( {
        children: [
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 0, 0 ) ) ),
            ...toArray( matrix.timesVector2( v2( 0, 10 ) ) ),
            phet.phetCore.merge( { fill: 'red', stroke: 'red' }, arrowOptions )
          ),
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 0, 0 ) ) ),
            ...toArray( matrix.timesVector2( v2( 10, 0 ) ) ),
            phet.phetCore.merge( { fill: 'red', stroke: 'red' }, arrowOptions )
          ),
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 10, 0 ) ) ),
            ...toArray( matrix.timesVector2( v2( 10, 10 ) ) ),
            phet.phetCore.merge( { fill: 'red', stroke: 'red' }, arrowOptions )
          ),
          new ArrowNode(
            ...toArray( matrix.timesVector2( v2( 0, 10 ) ) ),
            ...toArray( matrix.timesVector2( v2( 10, 10 ) ) ),
            phet.phetCore.merge( { fill: 'red', stroke: 'red' }, arrowOptions )
          )
        ]
      } );

      const edgeClipArrowLabelsNode = new phet.scenery.Node( {
        children: [
          new phet.scenery.Text( 'minY', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 5, -0.1 ) ) } ),
          new phet.scenery.Text( 'maxY', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 5, 10.1 ) ) } ),
          new phet.scenery.Text( 'minX', { font: window.diagramFont, rightCenter: matrix.timesVector2( v2( -0.1, 5 ) ) } ),
          new phet.scenery.Text( 'maxX', { font: window.diagramFont, leftCenter: matrix.timesVector2( v2( 10.1, 5 ) ) } )
        ]
      } );

      const edgeClippedArrowLabelsNode = new phet.scenery.Node( {
        children: [
          new phet.scenery.Text( '+1', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 5, -0.1 ) ) } ),
          new phet.scenery.Text( '0', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 5, 10.1 ) ) } ),
          new phet.scenery.Text( '-1', { font: window.diagramFont, rightCenter: matrix.timesVector2( v2( -0.1, 5 ) ) } ),
          new phet.scenery.Text( '0', { font: window.diagramFont, leftCenter: matrix.timesVector2( v2( 10.1, 5 ) ) } )
        ]
      } );

      const coordinateLabelsNode = new phet.scenery.Node( {
        children: [
          new phet.scenery.Text( '(0,0)', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 0, -0.1 ) ) } ),
          new phet.scenery.Text( '(0,10)', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 0, 10.1 ) ) } ),
          new phet.scenery.Text( '(10,0)', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 10, -0.1 ) ) } ),
          new phet.scenery.Text( '(9,9)', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 9, 9.1 ) ) } ),
          new phet.scenery.Text( '(6,9)', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 6, 9.1 ) ) } ),
          new phet.scenery.Text( '(9,6)', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 9, 5.9 ) ) } ),
          new phet.scenery.Text( '(2,10)', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 2, 10.1 ) ) } ),
          new phet.scenery.Text( '(10,2)', { font: window.diagramFont, leftCenter: matrix.timesVector2( v2( 10.1, 2 ) ) } ),
          new phet.scenery.Text( '(2,2)', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 2, 1.9 ) ) } ),
          new phet.scenery.Text( '(7,2)', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 7, 1.9 ) ) } ),
          new phet.scenery.Text( '(2,7)', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 2, 7.1 ) ) } )
        ]
      } );

      const cornerCoordinateLabelsNode = new phet.scenery.Node( {
        children: [
          new phet.scenery.Text( '(0,0)', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 0, -0.1 ) ) } ),
          new phet.scenery.Text( '(0,10)', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 0, 10.1 ) ) } ),
          new phet.scenery.Text( '(10,0)', { font: window.diagramFont, centerBottom: matrix.timesVector2( v2( 10, -0.1 ) ) } ),
          new phet.scenery.Text( '(10,10)', { font: window.diagramFont, centerTop: matrix.timesVector2( v2( 10, 10.1 ) ) } )
        ]
      } );

      // TODO: factor some of this code out...
      {
        const scene = new phet.scenery.Node( {
          children: [
            dottedRect,
            filledPath,
            arrowsNode,
            coordinateLabelsNode
          ]
        } );
        const div = document.createElement( 'div' );
        div.style.margin = '0 auto';
        const display = new phet.scenery.Display( scene, {
          width: outputSize,
          height: outputSize,
          accessibility: true,
          container: div,
          allowCSSHacks: false
        } );
        display.updateDisplay();
        document.getElementById( 'polygonal-face-example' ).appendChild( div );
      }

      {
        const scene = new phet.scenery.Node( {
          children: [
            dottedRect,
            filledPath,
            arrowsNode,
            extraArrowsNode
          ]
        } );
        const div = document.createElement( 'div' );
        div.style.margin = '0 auto';
        const display = new phet.scenery.Display( scene, {
          width: outputSize,
          height: outputSize,
          accessibility: true,
          container: div,
          allowCSSHacks: false
        } );
        display.updateDisplay();
        document.getElementById( 'polygonal-face-canceling' ).appendChild( div );
      }

      {
        const scene = new phet.scenery.Node( {
          children: [
            dottedRect,
            edgeClipArrowsNode,
            cornerCoordinateLabelsNode,
            edgeClipArrowLabelsNode
          ]
        } );
        const div = document.createElement( 'div' );
        div.style.margin = '0 auto';
        const display = new phet.scenery.Display( scene, {
          width: outputSize,
          height: outputSize,
          accessibility: true,
          container: div,
          allowCSSHacks: false
        } );
        display.updateDisplay();
        document.getElementById( 'polygonal-face-edge-clips' ).appendChild( div );
      }

      {
        const scene = new phet.scenery.Node( {
          children: [
            dottedRect,
            filledPath,
            edgeClippedArrowsNode,
            coordinateLabelsNode,
            edgeClippedArrowLabelsNode
          ]
        } );
        const div = document.createElement( 'div' );
        div.style.margin = '0 auto';
        const display = new phet.scenery.Display( scene, {
          width: outputSize,
          height: outputSize,
          accessibility: true,
          container: div,
          allowCSSHacks: false
        } );
        display.updateDisplay();
        document.getElementById( 'polygonal-face-edge-clipped' ).appendChild( div );
      }
    </script>

    <h3 id="clipping">Clipping</h3>

    <h4>Line Clipping</h4>

    The first primitive we'll need is the ability to find the part of a line segment that is within an axis-aligned
    bounding rectangle (referred to as bounds). Alpenglow primarily uses <a href="https://aircconline.com/ijcga/V9N3/9319ijcga01.pdf">Another Simple but Faster Method for 2D Line Clipping</a> by
    Matthes and Drakopoulos (2019).

    <div class="example">
      <div id="clipping-line-example"></div>
    </div>

    <script type="module">
      const outputSize = 256;
      const size = 10;
      const padding = 70;

      const matrix = phet.dot.Matrix3.translation( padding, padding ).timesMatrix( phet.dot.Matrix3.scaling( ( outputSize - 2 * padding ) / size ) );
      const bounds = new phet.dot.Bounds2( 0, 0, 10, 10 );

      const clipRect = phet.scenery.Rectangle.bounds( bounds.transformed( matrix ), {
        stroke: 'black',
        fill: 'white'
      } );

      const exteriorShape = new phet.kite.Shape();
      const interiorShape = new phet.kite.Shape();

      const v2 = phet.dot.v2;
      const LinearEdge = phet.alpenglow.LinearEdge;
      const edges = [
        new LinearEdge( v2( -2, 7 ), v2( 7, -2 ) ),
        new LinearEdge( v2( 3, 4 ), v2( 9, 6 ) ),
        new LinearEdge( v2( 5, -5 ), v2( 15, 4 ) ),
        new LinearEdge( v2( 4, 7 ), v2( 9, 12 ) ),
        new LinearEdge( v2( 2, 10 ), v2( 1, 13 ) ),
        new LinearEdge( v2( 0, 9 ), v2( 2, 9 ) )
      ];

      for ( let i = 0; i < edges.length; i++ ) {
        const start = edges[ i ].startPoint.copy();
        const end = edges[ i ].endPoint.copy();

        const fullStart = start.copy();
        const fullEnd = end.copy();

        const clipped = phet.alpenglow.LineClipping.matthesDrakopoulosClip( start, end, 0, 0, 10, 10 );

        if ( clipped ) {
          if ( !start.equals( fullStart ) ) {
            exteriorShape.moveToPoint( matrix.timesVector2( fullStart ) );
            exteriorShape.lineToPoint( matrix.timesVector2( start ) );
          }

          if ( !start.equals( end ) ) {
            interiorShape.moveToPoint( matrix.timesVector2( start ) );
            interiorShape.lineToPoint( matrix.timesVector2( end ) );
          }

          if ( !end.equals( fullEnd ) ) {
            exteriorShape.moveToPoint( matrix.timesVector2( end ) );
            exteriorShape.lineToPoint( matrix.timesVector2( fullEnd ) );
          }
        }
        else {
          exteriorShape.moveToPoint( matrix.timesVector2( fullStart ) );
          exteriorShape.lineToPoint( matrix.timesVector2( fullEnd ) );
        }
      }

      const exteriorNode = new phet.scenery.Path( exteriorShape, {
        stroke: 'black',
        opacity: 0.2
      } );
      const interiorNode = new phet.scenery.Path( interiorShape, {
        stroke: 'red'
      } );

      {
        const scene = new phet.scenery.Node( {
          children: [
            clipRect,
            exteriorNode,
            interiorNode
          ]
        } );
        const div = document.createElement( 'div' );
        div.style.margin = '0 auto';
        const display = new phet.scenery.Display( scene, {
          width: outputSize,
          height: outputSize,
          accessibility: true,
          container: div,
          allowCSSHacks: false
        } );
        display.updateDisplay();
        document.getElementById( 'clipping-line-example' ).appendChild( div );
      }
    </script>

    <p class="TODO">Documentation</p>

    <p class="TODO">Edge-Clipped note about preservation of counts</p>

    <h3 id="antialiasing">Anti-Aliasing</h3>

    <p class="TODO">Documentation</p>

    <p class="TODO">Demos of concepts, blurs, and checkerboard/siemens examples</p>

    <h3 id="renderProgram">RenderProgram</h3>

    <p class="TODO">Documentation</p>

    <h4 id="RenderColor">RenderColor</h4>

    <p>
      RenderColor displays a single solid color everywhere, and is a basic building-block for many other RenderPrograms.
    </p>

    <div class="example">
      <div id="RenderColor-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderColor-example', () => {
        /*START*/
        const program = new RenderColor( new Vector4( 1, 0, 0, 1 ) );
        /*END*/
        return program;
      }, 128, 128 );
    </script>

    <p>
      Note that the default color space is <a href="https://en.wikipedia.org/wiki/SRGB">sRGB</a>. Additionally, the
      values are by default interpreted with
      <a href="https://en.wikipedia.org/wiki/Alpha_compositing#Straight_versus_premultiplied">premultiplied alpha</a>
      (also called associated alpha), so <code>0.5, 0, 0, 0.5</code> will represent a 50% transparent fully-red color.
    </p>

    <h4 id="RenderPathBoolean">RenderPathBoolean</h4>

    <p>
      RenderPathBoolean will display one RenderProgram "inside" the path, and another RenderProgram "outside" the path.
    </p>

    <div class="example">
      <div id="RenderPathBoolean-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderPathBoolean-example', () => {
        /*START*/
        const program = new RenderPathBoolean(
          // The path. We have a "fill rule" of nonzero, which defines which sections
          // are considered inside. See https://en.wikipedia.org/wiki/Nonzero-rule
          new RenderPath( 'nonzero', [ [
            v2( 20, 20 ),
            v2( 90, 40 ),
            v2( 118, 118 ),
            v2( 50, 80 )
          ] ] ),

          // The "inside" RenderProgram
          new RenderColor( new Vector4( 1, 0, 0, 1 ) ),

          // The "outside" RenderProgram
          new RenderColor( new Vector4( 0.8, 0.8, 0.8, 1 ) )
        );
        /*END*/
        return program;
      }, 128, 128 );
    </script>

    <h4 id="RenderStack">RenderStack</h4>

    <p>
      RenderStack will apply normal compositing/blending to a list of RenderPrograms, where each RenderProgram in the
      list is drawn "on top" of all of the previous ones.
    </p>

    <div class="example">
      <div id="RenderStack-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderStack-example', () => {
        /*START*/
        const program = new RenderStack( [
          // A constant background color
          new RenderColor( new Vector4( 0, 0, 0, 1 ) ),

          // Red diamond
          RenderPathBoolean.fromInside( // applies "transparent" to the "outside"
            new RenderPath( 'nonzero', [ [
              v2( 20, 20 ), v2( 90, 40 ), v2( 118, 118 ), v2( 50, 80 )
            ] ] ),
            new RenderColor( new Vector4( 1, 0, 0, 1 ) )
          ),

          // Green triangle
          RenderPathBoolean.fromInside(
            new RenderPath( 'nonzero', [ [
              v2( 10, 10 ), v2( 90, 10 ), v2( 10, 90 )
            ] ] ),
            new RenderColor( new Vector4( 0, 1, 0, 1 ) )
          ),

          // Semi-transparent white rectangle
          RenderPathBoolean.fromInside(
            new RenderPath( 'nonzero', [ [
              v2( 30, 30 ), v2( 110, 30 ), v2( 110, 80 ), v2( 30, 80 )
            ] ] ),
            new RenderColor( new Vector4( 0.7, 0.7, 0.7, 0.7 ) )
          )
        ] );
        /*END*/
        return program;
      }, 128, 128 );
    </script>

    <h4 id="RenderLinearBlend">RenderLinearBlend</h4>

    <p>
      RenderLinearBlend will interpolate between two different RenderPrograms based on the location. It will evaluate
      <code>clamp( dot( scaledNormal, point ) - offset, 0, 1 )</code>, and will linearly blend between the "zero"
      program (when the value is 0) and the "one" program (when the value is 1).
    </p>

    <p>
      It can be used in a standalone way, however it is primarily meant to be used when a <code>RenderLinearGradient</code>
      is split into each section between two gradient stops.
    </p>

    <div class="example">
      <div id="RenderLinearBlend-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderLinearBlend-example', () => {
        /*START*/
        const program = new RenderLinearBlend(
          new Vector2( 1 / 128, 0 ), // scaledNormal
          0, // offset
          RenderLinearBlendAccuracy.Accurate,

          // "zero" RenderProgram
          new RenderColor( new Vector4( 1, 0, 0, 1 ) ),

          // "one" RenderProgram
          new RenderColor( new Vector4( 0, 0, 1, 1 ) )
        );
        /*END*/
        return program;
      }, 128, 128 );
    </script>

    <h4 id="RenderLinearGradient">RenderLinearGradient</h4>

    <p>
      RenderLinearGradient will display the typical linear gradient.
    </p>

    <div class="example">
      <div id="RenderLinearGradient-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderLinearGradient-example', () => {
        /*START*/
        const program = new RenderLinearGradient(
          Matrix3.IDENTITY, // transform
          new Vector2( 0, 0 ), // start
          new Vector2( 50, 20 ), // end
          [
            new RenderGradientStop( 0, new RenderColor( new Vector4( 0, 0, 0, 1 ) ) ),
            new RenderGradientStop( 0.5, new RenderColor( new Vector4( 1, 0, 0, 1 ) ) ),
            new RenderGradientStop( 1, new RenderColor( new Vector4( 1, 1, 1, 1 ) ) )
          ],
          RenderExtend.Repeat, // Pad, Repeat, Reflect
          RenderLinearGradientAccuracy.SplitAccurate
        );
        /*END*/
        return program;
      }, 128, 128 );
    </script>

    <p class="TODO">
      NOTE: The shear cases are broken on splits, we can't just transform the points
    </p>

    <h4 id="RenderRadialBlend">RenderRadialBlend</h4>

    <p>
      RenderRadialBlend will interpolate between two different RenderPrograms based on the location. It will evaluate
      <code>clamp( ( averageFragmentRadius - radius0 ) / ( radius1 - radius0 ), 0, 1 )</code>, and will linearly blend
      between the "zero" program (when the value is 0) and the "one" program (when the value is 1).
    </p>

    <p>
      It can be used in a standalone way, however it is primarily meant to be used when a <code>RenderRadialGradient</code>
      is circular, and is split into each radial-linear partition.
    </p>

    <div class="example">
      <div id="RenderRadialBlend-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderRadialBlend-example', () => {
        /*START*/
        const program = new RenderRadialBlend(
          Matrix3.translation( 64, 64 ), // transform
          0, // radius0,
          64, // radius1
          RenderRadialBlendAccuracy.Accurate,

          // "zero" RenderProgram
          new RenderColor( new Vector4( 1, 0, 0, 1 ) ),

          // "one" RenderProgram
          new RenderColor( new Vector4( 0, 0, 1, 1 ) )
        );
        /*END*/
        return program;
      }, 128, 128 );
    </script>

    <h4 id="RenderRadialGradient">RenderRadialGradient</h4>

    <p>
      RenderRadialGradient will display the typical radial gradient.
    </p>

    <div class="example">
      <div id="RenderRadialGradient-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderRadialGradient-example', () => {
        /*START*/
        const program = new RenderRadialGradient(
          Matrix3.IDENTITY, // transform
          new Vector2( 0, 0 ), // start
          0, // startRadius
          new Vector2( 0, 0 ), // end
          64, // endRadius
          [
            new RenderGradientStop( 0, new RenderColor( new Vector4( 0, 0, 0, 1 ) ) ),
            new RenderGradientStop( 0.5, new RenderColor( new Vector4( 1, 0, 0, 1 ) ) ),
            new RenderGradientStop( 1, new RenderColor( new Vector4( 1, 1, 1, 1 ) ) )
          ],
          RenderExtend.Repeat, // Pad, Repeat, Reflect
          RenderRadialGradientAccuracy.SplitAccurate
        );
        /*END*/
        return program;
      }, 128, 128 );
    </script>

    <p class="TODO">The split "Reflect" extend type seems to be reversed from the desired behavior!</p>

    <p class="TODO">We need UnsplitCentroid to get more general conic gradients working, it should NOT split in those cases</p>

    <h4 id="RenderBlendCompose">RenderBlendCompose</h4>

    <p>
      RenderBlendCompose will blend/composite two RenderPrograms with a more general blending model, that takes in
      a Porter-Duff <a href="https://en.wikipedia.org/wiki/Alpha_compositing">compositing mode</a>, in addition to a
      <a href="https://en.wikipedia.org/wiki/Blend_modes">blend mode</a>.
    </p>

    <div class="example">
      <div id="RenderBlendCompose-example"></div>
    </div>

    <script type="module">
      /* eslint-disable no-undef */
      window.createRenderProgramSandbox( 'RenderBlendCompose-example', () => {
        const size = 90;
        const padding = 5;
        const n0 = padding;
        const n1 = ( size - 2 * padding ) / 3 + padding;
        const n2 = 2 * ( size - 2 * padding ) / 3 + padding;
        const n3 = 3 * ( size - 2 * padding ) / 3 + padding;
        /*START*/
        const exampleCompositeModes = [
          // There are a few more modes, for other compositing situations
          RenderComposeType.Over,
          RenderComposeType.In,
          RenderComposeType.Out,
          RenderComposeType.Atop,
          RenderComposeType.Xor
        ];
        const program = new RenderStack(
          exampleCompositeModes.map( ( composeMode, i ) => {
            const x = i * size;
            return new RenderBlendCompose(
              composeMode,
              RenderBlendType.Normal,
              RenderPathBoolean.fromInside(
                RenderPath.fromBounds( new Bounds2( x + n0, n0, x + n2, n2 ) ),
                new RenderColor( new Vector4( 1, 0, 0, 1 ) )
              ),
              RenderPathBoolean.fromInside(
                RenderPath.fromBounds( new Bounds2( x + n1, n1, x + n3, n3 ) ),
                new RenderColor( new Vector4( 0, 0.8, 0, 1 ) )
              )
            );
          } )
        );
        /*END*/
        return program;
      }, 5 * 90, 90 );
    </script>

    <p class="TODO">Add blend type example, once text is easier, like https://learn.microsoft.com/en-us/windows/win32/direct2d/blend</p>

    <p class="TODO">Docs/demo for RenderColorSpaceConversion (and color conversions), RenderPremultiply/RenderUnpremultiply</p>
    <p class="TODO">Docs/demo for RenderImage</p>
    <p class="TODO">Docs/demo for RenderAlpha</p>
    <p class="TODO">Docs/demo for RenderFilter</p>
    <p class="TODO">Docs/demo for RenderBarycentricBlend</p>
    <p class="TODO">Docs/demo for RenderBarycentricPerspectiveBlend</p>
    <p class="TODO">Docs/demo for RenderDepthSort / RenderPlanar</p>
    <p class="TODO">Docs/demo for RenderPhong / RenderLight / RenderNormalize</p>

    <h4 id="renderProgram-simplification">Simplification</h4>

    <p class="TODO">Documentation</p>

    <h4 id="renderProgram-execution">Execution</h4>

    <p>
      The software tree form of RenderPrograms can be directly executed. However it's better if we turn our RenderProgram
      into a series of instructions that can be executed in a more efficient way.
    </p>

    <p>
      We're able to output instructions (both in software as types, and on the GPU in a binary format) that operate in
      a simple stack-based fashion. We'll have a main stack, where vec4 values are pushed and popped. Instructions
      primarily either push content, or pop content then push more content (processing existing values). We're able to
      determine a bound on the stack size by analyzing the RenderProgram (normal visual blending won't cause stack
      issues, since we're able to blend each pair of colors before computing the next color).
    </p>

    <p>
      This is combined with a stack of instruction indices, to support function calls and return values, in addition to
      simple branching logic. It turns out all of the primitives we need can be done with "opaque jumps" (if the top of
      the stack is a fully-opaque value, jump to an instruction index) and function calls.
    </p>

    <p class="TODO">
      Add "stack depth" getters to RenderProgram (both the main and instruction stacks), so we know what depth is needed.
      RenderPhong can use up a good amount of stack space (ambient/diffuse/specular/position/normal + direction/color for
      each light), BUT we really want to minimize the memory individual invocations/threads take up during execution.
      We can customize the stack sizes at shader creation time... maybe we can do pipeline-overloadable constants
      instead?
    </p>

    <p class="TODO">
      Document RenderInstruction
    </p>

    <p class="TODO">
      Add examples of the binary format, or examples of simple things like what a gradient turns into.
      Do it from our instructionTest() playground example
    </p>

    <p class="TODO">
      Consider separating out the RenderInstruction items into its own subdirectory. Potentially the logic items also.
    </p>

    <p class="TODO">
      Add error handling to detect if we blow past a stack?
    </p>

    <p class="TODO">
      Detect if we run past a buffer, and set a flag so we can restart with a larger buffer? This will still cause a delay...
    </p>

    <p class="TODO">
      Bake in support for context loss handling
    </p>

    <h3 id="WGSL">WGSL</h3>

    <p class="TODO">
      <a href="https://github.com/wgsl-analyzer/wgsl-analyzer">wgsl-analyzer</a> our non-minified output!
    </p>

    <h4 id="WGSL-snippets">Snippets</h4>

    <p class="TODO">Note DualSnippet. Note ComputeShader</p>

    <h4 id="WGSL-preprocessing">Preprocessing</h4>

    <p class="TODO">NOTE #ifdef/#ifndef/#else/#endif #import #option #bindings</p>

    <h4 id="WGSL-minification">Minification</h4>

    <p class="TODO">Note progress on minification. TEST WITH IT ON</p>

    <p class="TODO">Note chipper <code>node js/scripts/transpile.js --watch --skipMinifyWGSL</code></p>

    <h4 id="WGSL-mangling">Mangling</h4>

    <p class="TODO">
      Mangling needs to run on all of the shader code at once. We've implemented mangling for the Vello setup, but we
      need to implement it in the chipper transpiler.
    </p>

    <h2 id="stages">Stages</h2>

    <h3 id="stage-transforms">Transforms</h3>

    <p>
      Use a stack monoid setup to compute the nested transforms for every path. This isn't particularly required from
      Scenery (we CAN compute them CPU-side, but it uses up a lot of CPU time). However, we can ship over paths in an
      instanced fashion (e.g. font glyphs), and this stage would convert from the DAG to effectively a flat array of
      paths.
    </p>

    <h3 id="stage-subdivision">Subdivision</h3>

    <p>
      We'll want to convert our paths to polygons (a piecewise linear form). This could come before or after the
      transform step. Might need more code to do it after the transforms (logic needed to transform elliptical arcs,
      etc., but it would be more efficient.
    </p>

    <h3 id="stage-bounds">Bounds</h3>

    <p>
      We'll want the bounds of each path for later stages.
    </p>

    <h3 id="stage-tiling">Tiling</h3>

    <p>
      We'll subdivide the rendered area into tiles, and for each path we'll either skip it, fully include it, or clip it
      to the size of the tile.
    </p>

    <p>
      Certain potential final rasterization steps benefit from a guaranteed maximum tile size of path (e.g. if we're
      256x256, it would take 16 steps of binary subdivision to reach the pixel level).
    </p>

    <p>
      Tiling is also helpful to reduce the potential amount of cases for the later intersection step, AND with our
      integer transform, we'll be able to keep more precision for the CAG steps.
    </p>

    <h3 id="stage-integerTransform">Integer Transform</h3>

    <p>
      We'll scale up and transform our coordinate frame (for each tile) to integer coordinates, spaced out so that we're
      keeping about 20 bits of information for each coordinate. This will allow us to use rational numbers to compute
      the intersections between line segments (and to sort edges around each vertex) in an exact robust way, keeping our
      numerator and denominator within 64 bits each. Since the outputs will be signed, we'll want to put the origin
      approximately in the center of our "integer" coordinate frame.
    </p>

    <p>
      Our data will be in the <code>IntegerEdge</code> format, which essentially just stores the start point, end point,
      and the path ID.
    </p>

    <h3 id="stage-hilbertSort">Hilbert Sort</h3>

    <p>
      We'll sort the the edges using a higher-dimensional
      <a href="https://en.wikipedia.org/wiki/Hilbert_curve">Hilbert space-filling curve</a>, so that edges are somewhat
      spatially coherent (edges in a similar part of the list will likely have similar positions or sizes). This helps
      reduce the workload on the next step (intersection), since it would have theoretical O(n^2) performance.
      In practice, by having typical visual data AND sorting, we get a small fraction of that!
    </p>

    <p>
      This may be unnecessary for some workloads (where the edges provided are in a spatially coherent order due to
      the scene graph), however it's absolutely necessary for others (e.g. 3d meshes).
    </p>

    <p>
      This is inspired by the bulk loading of R-Trees (see <a href="https://dl.acm.org/doi/abs/10.1145/1963190.2025380">Four-dimensional hilbert curves for R-trees</a>, Haverkort et al. 2008).
    </p>

    <p>
      Planned to use a radix sort on GPU. Software is currently using a 6-dimensional Hilbert sort
      (centerX, centerY, minX, minY, maxX, maxY), but it's probably best to reduce that to a 4-dimensional sort.
    </p>

    <h3 id="stage-intersection">Intersection</h3>

    <p>
      We'll need to find all of the pairwise intersections between edges. In software, this is done by computing a
      binary tree of bounding boxes (where the Hilbert sort helps significantly). We can ignore the intersection between
      two subtrees whose bounding boxes do not intersect. Furthermore, if there are no horizontal lines in either
      subtree, we can allow the bounding boxes to "touch" horizontally (sharing a single line of intersection) without
      having any substantive pairwise intersection in edges, since we only care about internal intersections (those
      which aren't endpoint-to-endpoint).
    </p>

    <p>
      We'll store the intersections with their rational coordinates AND parametric value of intersection (also an
      exact rational) for each internal intersection within each of the edges.
    </p>

    <p>
      This intersection will also detect overlapping segments, and will find the endpoints that are internal to the
      other edge. Thus overlapping edges will thus be fully overlapping, and can be detected by future steps.
    </p>

    <p>
      Potentially plan to use bump allocation on the GPU, with a linked list for each edge (with atomic operations).
    </p>

    <h3 id="stage-split">Split</h3>

    <p>
      Each integer edge will have a list of internal intersections. We'll sort those intersections by their parametric
      value, and then we'll output a list of "rational" edges (using `RationalHalfEdge`) that make up each
      non-intersected interval of the original edge.
    </p>

    <p>
      We'll store the winding information for each path in this information. So if our edge in path X goes from A to B,
      we'll create two half-edges: A -> B (winding +1) and B -> A (winding -1), both marked for path X.
    </p>

    <h3 id="stage-edgeSort">Edge Sort</h3>

    <p>
      We'll sort our rational half-edges for the next stage (first by their starting point, then by their angle, then
      by their ID).
    </p>

    <h3 id="stage-filterConnect">Filter &amp; Connect</h3>

    <p>
      There are two goals here:
    </p>

    <ul>
      <li>
        Combine otherwise identical overlapping half-edges together. Before this, each directional edge has one path
        that it's from, but now each half-edge will be from potentially multiple paths. We'll combine the winding
        contributions into a winding map (path => winding) for these cases. (NOTE: we're currently duplicating effort
        for the reverse edges here). We'll want to filter out duplicates (stream compaction on GPU).
      </li>
      <li>
        Connecting our half-edge structure together. Each half-edge already had a link to its "opposite" edge. However
        since we now have edges that are sorted by start THEN angle, we have effectively "ordered" all of the outgoing
        edges around each vertex, and thus we can store our "next" and "previous" half-edges if tracing
        counter-clockwise around the vertex. This will allow tracing of the edges in future steps.
      </li>
    </ul>

    <h3 id="stage-boundaryTrace">Boundary Trace</h3>

    <p>
      We'll follow each half-edge until it loops back on itself. This will give us a boundary. It might be an
      "inner" or "outer" boundary. We can determine which it is by looking at the total signed area of the boundary
      (using the shoelace method). If it's positive, it's an inner boundary (is counter-clockwise), and if it's
      negative, it's an outer boundary (is clockwise). Outer boundaries are either (a) the outside of the bounding box
      or whatever region we have, or (b) a hole.
    </p>

    <p>
      Since we have signed area here, we can discard all edges with boundaries with zero area.
    </p>

    <p>
      On the GPU, we'll be able to use reduction techniques to make this efficient (like the linked list traversal).
    </p>

    <h3 id="stage-faceHoles">Face Holes</h3>

    <p>
      Each inner boundary determines a face. We need to compute which outer boundaries are holes, and for which faces.
      Once we figure out which boundaries are holes for which faces, we can forget about whether they are inner/outer
      and just combine all of the relevant boundaries together to represent the face.
    </p>

    <p>
      We'll first sort faces by their signed area. Then for each outer boundary, we'll take the point on it with the
      smallest x value (compatible with our edge sort above), and we'll scan for the smallest face that contains the
      point. We can filter a lot, ignoring faces smaller than the hole, faces whose bounding boxes don't fully
      (strictly) contain our hole, and we can take the smallest face that contains the point. Point-in-polygon testing
      is done with Dan Sunday's algorithm.
    </p>

    <p class="TODO">
      Look up what paper most of the filtering techniques are from!
    </p>

    <p>
      As part of this, we'll determine the "unbounded" outer face (the one that effectively contains the content OUTSIDE
      of the region we're rendering).
    </p>

    <h3 id="stage-windingMaps">Winding Maps</h3>

    <p>
      We need to compute the winding map for each face. The unbounded face contains zero winding, so we can start with
      it and find adjacent faces (through edges). Each time we find an adjacent edge with one face that has a winding
      map and one that doesn't, we can compute the winding map for the face that doesn't have one (based on the
      information in the edge and in the one face).
    </p>

    <h3 id="stage-renderProgramSimplification">RenderProgram Simplification</h3>

    <p>
      Our winding map for each face, combined with the winding rule for each path, gives us a boolean map (whether
      a path is included or not) for each face. In general these are sparse, so they will only mention the included
      faces. We can simplify the RenderProgram for each face by simplifying it with the path inclusion information
      (replacing each <code>RenderPathBoolean</code> with either the inside or outside RenderProgram), combined with
      simplification.
    </p>

    <p>
      We will precompute (possibly on the CPU) a replacement acceleration structure, since we'll have many primitives
      that will simplify sparse path inclusion significantly. Thus if we have 1000 paths, and 3 of them are included
      in a face, we can create a simplified version of that RenderProgram without having to do a full scan of the 1000
      items. See <code>RenderPathReplacer</code> for more details.
    </p>

    <p class="TODO">
      Write up RenderPathReplacer documentation.
    </p>

    <p>
      Now, many of the faces will have constant-valued RenderPrograms, which can be rendered much more efficiently!
      We won't have to do per-pixel blending at all in these cases.
    </p>

    <h3 id="stage-renderableFaceCreation">RenderableFace Creation</h3>

    <p>
      There now might be multiple faces that have equivalent RenderPrograms (especially those that are adjacent faces).
      Based on performance characteristics, we may want to do one of the following:
    </p>

    <dl>
      <dt>
        Keep the faces separate
      </dt>
      <dd>
        Straightforward, but we'll process more edges than needed.
      </dd>
      <dt>
        Combine adjacent equivalent faces (just delete edges)
      </dt>
      <dd>
        We can scan edges to find ones with equivalent faces on both sides. We can then discard these edges, and deliver
        edges out in the "unsorted edge" format (ideally edge-clipped) for future stages.
      </dd>
      <dt>
        Combine adjacent equivalent faces (trace edges, skip equivalent)
      </dt>
      <dd>
        If we instead trace edges, and while traversing we skip over edges that have equivalent faces, we'll generate
        polygonal data for each face. This will leave us with the best end-result, but might be more costly.
      </dd>
      <dt>
        Fully combine all equivalent faces
      </dt>
      <dd>
        This could be done with "unsorted edges" or traced. We'll get a full path for each RenderProgram, however
        depending on the rasterization method used, having two far-away small items in the same face could hurt
        performance.
      </dd>
    </dl>

    <p class="TODO">
      NOTE: This is better implemented by generating hashes for every simplified RenderProgram, so we can do quick
      comparisons.
    </p>

    <p class="TODO">
      Visuals/examples would be helpful here.
    </p>

    <h3 id="stage-splitPrograms">Split Programs</h3>

    <p>
      Certain types of RenderPrograms will cause their RenderableFace to be split into multiple RenderableFaces. For
      example, the <code>RenderDepthSort</code> for 3d meshes will be able to find exact split lines between different
      3d faces fully included in the RenderableFace. Additionally, for high quality output, gradients can split their
      faces so that gradient stop transitions are properly anti-aliased.
    </p>

    <h3 id="stage-rasterize">Rasterize</h3>

    <p>
      We'll want to take the path representation for each RenderableFace, and determine the coverage of each pixel.
    </p>

    <p class="TODO">
      Fix up render program indices in RasterClipper, test with multiple RenderPrograms, get the demo here.
    </p>

    <p class="TODO">
      IMPORTANT! Our resulting edge-clipped counts should be cyclic, right? Only use 2 bits per count!!
      They should wrap around or accumulate as long as we do arithmetic mod 4.
      Right now we're taking up 4x i32 for this, and that's (a) excessive, (b) killing performance, and (c) reducing
      the size of our potential workgroups.
    </p>

    <p class="TODO">
      Document the approaches here.
    </p>

    <p class="TODO">
      Add mermaid chart here
    </p>

    <p class="TODO">
      Show which parts finish in which stages, if we stick to that?
    </p>

  </div>
  <div class="span2"></div>
</div>

</body>
</html>
